# School Management System - Complete Spring Boot 3.5.7 API Implementation
## Remaining Services (Class, Fee, Parent Portal, Exam, Library, Principal Dashboard, Support, Notification)

---

## FEE/PAYMENT SERVICE

### FeeStructure Entity
```java
package com.schoolmgmt.fee.entity;

import jakarta.persistence.*;
import lombok.*;
import java.math.BigDecimal;
import java.time.LocalDateTime;

@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
@Entity
@Table(name = "fee_structure", indexes = {
    @Index(name = "idx_class_id", columnList = "class_id"),
    @Index(name = "idx_academic_year", columnList = "academic_year")
})
public class FeeStructure {
    
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long feeStructureId;
    
    @Column(nullable = false)
    private Long classId;
    
    @Enumerated(EnumType.STRING)
    @Column(nullable = false)
    private FeeType feeType;
    
    @Column(nullable = false, precision = 10, scale = 2)
    private BigDecimal amount;
    
    @Enumerated(EnumType.STRING)
    @Column(nullable = false)
    private FeeFrequency frequency;
    
    @Column(nullable = false, length = 10)
    private String academicYear;
    
    private Integer dueDate;
    
    @Column(name = "created_at", nullable = false, updatable = false)
    private LocalDateTime createdAt;
    
    @Column(name = "updated_at")
    private LocalDateTime updatedAt;
    
    @PrePersist
    protected void onCreate() {
        this.createdAt = LocalDateTime.now();
    }
    
    @PreUpdate
    protected void onUpdate() {
        this.updatedAt = LocalDateTime.now();
    }
}

public enum FeeType {
    TUITION, TRANSPORT, EXAM, LIBRARY, SPORTS, OTHER
}

public enum FeeFrequency {
    MONTHLY, QUARTERLY, HALF_YEARLY, YEARLY, ONE_TIME
}
```

### FeePayment Entity
```java
package com.schoolmgmt.fee.entity;

import jakarta.persistence.*;
import lombok.*;
import java.math.BigDecimal;
import java.time.LocalDate;
import java.time.LocalDateTime;

@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
@Entity
@Table(name = "fee_payments", indexes = {
    @Index(name = "idx_student_id", columnList = "student_id"),
    @Index(name = "idx_payment_status", columnList = "status")
})
public class FeePayment {
    
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long paymentId;
    
    @Column(nullable = false)
    private Long studentId;
    
    private Long invoiceId;
    
    @Column(nullable = false, unique = true, length = 50)
    private String receiptNumber;
    
    @Column(nullable = false)
    private LocalDate paymentDate;
    
    @Column(nullable = false, precision = 10, scale = 2)
    private BigDecimal amount;
    
    @Enumerated(EnumType.STRING)
    @Column(nullable = false)
    private PaymentMode paymentMode;
    
    @Column(length = 100)
    private String transactionRef;
    
    @Enumerated(EnumType.STRING)
    @Column(nullable = false)
    private PaymentStatus status;
    
    @Column(columnDefinition = "TEXT")
    private String remarks;
    
    private Long receivedByUserId;
    
    @Column(name = "created_at", nullable = false, updatable = false)
    private LocalDateTime createdAt;
    
    @Column(name = "updated_at")
    private LocalDateTime updatedAt;
    
    @PrePersist
    protected void onCreate() {
        this.createdAt = LocalDateTime.now();
    }
    
    @PreUpdate
    protected void onUpdate() {
        this.updatedAt = LocalDateTime.now();
    }
}

public enum PaymentMode {
    CASH, CHEQUE, ONLINE, CARD, UPI
}

public enum PaymentStatus {
    SUCCESS, FAILED, PENDING, REFUNDED
}
```

### FeePaymentDTO
```java
package com.schoolmgmt.fee.dto;

import lombok.*;
import jakarta.validation.constraints.*;
import java.math.BigDecimal;
import java.time.LocalDate;

@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
public class FeePaymentDTO {
    
    private Long paymentId;
    
    @NotNull(message = "Student ID is required")
    private Long studentId;
    
    private Long invoiceId;
    
    @NotBlank(message = "Receipt number is required")
    @Size(max = 50)
    private String receiptNumber;
    
    @NotNull(message = "Payment date is required")
    @PastOrPresent
    private LocalDate paymentDate;
    
    @NotNull(message = "Amount is required")
    @DecimalMin(value = "0.01", message = "Amount must be greater than 0")
    private BigDecimal amount;
    
    @NotNull(message = "Payment mode is required")
    private String paymentMode;
    
    private String transactionRef;
    private String status;
    private String remarks;
}

@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
public class FeeInvoiceDTO {
    
    private Long invoiceId;
    
    @NotNull(message = "Student ID is required")
    private Long studentId;
    
    @NotBlank(message = "Invoice number is required")
    private String invoiceNumber;
    
    @NotNull(message = "Invoice date is required")
    private LocalDate invoiceDate;
    
    @NotNull(message = "Due date is required")
    private LocalDate dueDate;
    
    @NotNull(message = "Total amount is required")
    @DecimalMin("0.01")
    private BigDecimal totalAmount;
    
    @DecimalMin("0.0")
    private BigDecimal discount;
    
    @DecimalMin("0.0")
    private BigDecimal tax;
    
    @DecimalMin("0.01")
    private BigDecimal netAmount;
    
    private String status;
}
```

### FeeService
```java
package com.schoolmgmt.fee.service;

import com.schoolmgmt.config.exception.ResourceNotFoundException;
import com.schoolmgmt.fee.dto.FeePaymentDTO;
import com.schoolmgmt.fee.entity.*;
import com.schoolmgmt.fee.repository.FeePaymentRepository;
import com.schoolmgmt.fee.repository.FeeStructureRepository;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.cache.annotation.CacheEvict;
import org.springframework.cache.annotation.Cacheable;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.math.BigDecimal;
import java.time.LocalDate;

@Slf4j
@Service
@RequiredArgsConstructor
@Transactional
public class FeeService {
    
    private final FeePaymentRepository feePaymentRepository;
    private final FeeStructureRepository feeStructureRepository;
    
    @CacheEvict(value = "fees", allEntries = true)
    public FeePaymentDTO recordPayment(FeePaymentDTO paymentDTO) {
        log.info("Recording fee payment for student: {}", paymentDTO.getStudentId());
        
        FeePayment payment = FeePayment.builder()
            .studentId(paymentDTO.getStudentId())
            .invoiceId(paymentDTO.getInvoiceId())
            .receiptNumber(paymentDTO.getReceiptNumber())
            .paymentDate(paymentDTO.getPaymentDate())
            .amount(paymentDTO.getAmount())
            .paymentMode(PaymentMode.valueOf(paymentDTO.getPaymentMode()))
            .transactionRef(paymentDTO.getTransactionRef())
            .status(PaymentStatus.SUCCESS)
            .remarks(paymentDTO.getRemarks())
            .build();
        
        payment = feePaymentRepository.save(payment);
        return mapToDTO(payment);
    }
    
    @Cacheable(value = "fees", key = "#studentId")
    public Page<FeePaymentDTO> getStudentPaymentHistory(Long studentId, Pageable pageable) {
        return feePaymentRepository.findByStudentId(studentId, pageable)
            .map(this::mapToDTO);
    }
    
    @Cacheable(value = "fee_defaulters")
    public Page<FeePaymentDTO> getFeeDefaulters(Pageable pageable) {
        return feePaymentRepository.findDefaulters(pageable)
            .map(this::mapToDTO);
    }
    
    public BigDecimal getOutstandingAmount(Long studentId) {
        return feePaymentRepository.findOutstandingAmount(studentId)
            .orElse(BigDecimal.ZERO);
    }
    
    @Cacheable(value = "fee_report", key = "'collection_' + #startDate + '_' + #endDate")
    public FeeCollectionReport generateCollectionReport(LocalDate startDate, LocalDate endDate) {
        log.info("Generating fee collection report from {} to {}", startDate, endDate);
        
        Page<FeePayment> payments = feePaymentRepository
            .findByPaymentDateBetween(startDate, endDate, Pageable.unpaged());
        
        BigDecimal totalCollection = payments.getContent().stream()
            .map(FeePayment::getAmount)
            .reduce(BigDecimal.ZERO, BigDecimal::add);
        
        return FeeCollectionReport.builder()
            .startDate(startDate)
            .endDate(endDate)
            .totalCollection(totalCollection)
            .totalTransactions(payments.getTotalElements())
            .build();
    }
    
    private FeePaymentDTO mapToDTO(FeePayment payment) {
        return FeePaymentDTO.builder()
            .paymentId(payment.getPaymentId())
            .studentId(payment.getStudentId())
            .invoiceId(payment.getInvoiceId())
            .receiptNumber(payment.getReceiptNumber())
            .paymentDate(payment.getPaymentDate())
            .amount(payment.getAmount())
            .paymentMode(payment.getPaymentMode().name())
            .transactionRef(payment.getTransactionRef())
            .status(payment.getStatus().name())
            .remarks(payment.getRemarks())
            .build();
    }
}

@Data
@Builder
class FeeCollectionReport {
    private LocalDate startDate;
    private LocalDate endDate;
    private BigDecimal totalCollection;
    private long totalTransactions;
}
```

### FeeController
```java
package com.schoolmgmt.fee.controller;

import com.schoolmgmt.fee.dto.FeePaymentDTO;
import com.schoolmgmt.fee.service.FeeService;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.security.access.prepost.PreAuthorize;
import org.springframework.web.bind.annotation.*;

import jakarta.validation.Valid;
import java.time.LocalDate;

@Slf4j
@RestController
@RequestMapping("/fees")
@RequiredArgsConstructor
@CrossOrigin(origins = "*", maxAge = 3600)
public class FeeController {
    
    private final FeeService feeService;
    
    @PostMapping("/pay")
    @PreAuthorize("hasRole('ADMIN') or hasRole('PRINCIPAL')")
    public ResponseEntity<FeePaymentDTO> recordPayment(@Valid @RequestBody FeePaymentDTO paymentDTO) {
        log.info("Recording fee payment");
        FeePaymentDTO payment = feeService.recordPayment(paymentDTO);
        return ResponseEntity.status(HttpStatus.CREATED).body(payment);
    }
    
    @GetMapping("/student/{studentId}/payments")
    @PreAuthorize("hasRole('ADMIN') or hasRole('PRINCIPAL') or hasRole('PARENT')")
    public ResponseEntity<Page<FeePaymentDTO>> getPaymentHistory(
            @PathVariable Long studentId,
            Pageable pageable) {
        log.info("Fetching payment history for student: {}", studentId);
        Page<FeePaymentDTO> payments = feeService.getStudentPaymentHistory(studentId, pageable);
        return ResponseEntity.ok(payments);
    }
    
    @GetMapping("/student/{studentId}/due")
    @PreAuthorize("hasRole('ADMIN') or hasRole('PRINCIPAL') or hasRole('PARENT')")
    public ResponseEntity<?> getDueAmount(@PathVariable Long studentId) {
        log.info("Fetching due amount for student: {}", studentId);
        return ResponseEntity.ok(Map.of("studentId", studentId, 
            "dueAmount", feeService.getOutstandingAmount(studentId)));
    }
    
    @GetMapping("/defaulters")
    @PreAuthorize("hasRole('ADMIN') or hasRole('PRINCIPAL')")
    public ResponseEntity<Page<FeePaymentDTO>> getFeeDefaulters(Pageable pageable) {
        log.info("Fetching fee defaulters");
        Page<FeePaymentDTO> defaulters = feeService.getFeeDefaulters(pageable);
        return ResponseEntity.ok(defaulters);
    }
    
    @GetMapping("/reports/collection")
    @PreAuthorize("hasRole('ADMIN') or hasRole('PRINCIPAL')")
    public ResponseEntity<?> generateCollectionReport(
            @RequestParam LocalDate startDate,
            @RequestParam LocalDate endDate) {
        log.info("Generating fee collection report");
        return ResponseEntity.ok(feeService.generateCollectionReport(startDate, endDate));
    }
}
```

---

## CLASS SERVICE

### Class Entity
```java
package com.schoolmgmt.class_service.entity;

import jakarta.persistence.*;
import lombok.*;
import java.time.LocalDateTime;

@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
@Entity
@Table(name = "classes", indexes = {
    @Index(name = "idx_class_name_year", columnList = "class_name,academic_year", unique = true)
})
public class Class {
    
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long classId;
    
    @Column(nullable = false, length = 50)
    private String className;
    
    @Column(nullable = false)
    private Integer classNumeric;
    
    @Column(nullable = false, length = 10)
    private String academicYear;
    
    private Long classTeacherId;
    
    @Column(name = "created_at", nullable = false, updatable = false)
    private LocalDateTime createdAt;
    
    @Column(name = "updated_at")
    private LocalDateTime updatedAt;
    
    @PrePersist
    protected void onCreate() {
        this.createdAt = LocalDateTime.now();
    }
    
    @PreUpdate
    protected void onUpdate() {
        this.updatedAt = LocalDateTime.now();
    }
}
```

### Subject Entity
```java
package com.schoolmgmt.class_service.entity;

import jakarta.persistence.*;
import lombok.*;
import java.time.LocalDateTime;

@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
@Entity
@Table(name = "subjects")
public class Subject {
    
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long subjectId;
    
    @Column(nullable = false, length = 100)
    private String subjectName;
    
    @Column(nullable = false, unique = true, length = 20)
    private String subjectCode;
    
    private Long classId;
    
    @Enumerated(EnumType.STRING)
    private SubjectType subjectType;
    
    private Integer maxMarks;
    private Integer passMarks;
    
    @Column(name = "created_at", nullable = false, updatable = false)
    private LocalDateTime createdAt;
    
    @PrePersist
    protected void onCreate() {
        this.createdAt = LocalDateTime.now();
    }
}

public enum SubjectType {
    THEORY, PRACTICAL, BOTH
}
```

### Timetable Entity
```java
package com.schoolmgmt.class_service.entity;

import jakarta.persistence.*;
import lombok.*;
import java.time.LocalTime;
import java.time.LocalDateTime;

@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
@Entity
@Table(name = "timetable", indexes = {
    @Index(name = "idx_class_id_date", columnList = "class_id,day_of_week")
})
public class Timetable {
    
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long timetableId;
    
    @Column(nullable = false)
    private Long classId;
    
    private Long sectionId;
    
    @Column(nullable = false)
    private Long subjectId;
    
    @Column(nullable = false)
    private Long teacherId;
    
    @Column(nullable = false)
    private Integer dayOfWeek;
    
    @Column(nullable = false)
    private Integer periodNumber;
    
    @Column(nullable = false)
    private LocalTime startTime;
    
    @Column(nullable = false)
    private LocalTime endTime;
    
    @Column(length = 20)
    private String roomNumber;
    
    @Column(nullable = false, length = 10)
    private String academicYear;
    
    @Column(name = "created_at", nullable = false, updatable = false)
    private LocalDateTime createdAt;
    
    @PrePersist
    protected void onCreate() {
        this.createdAt = LocalDateTime.now();
    }
}
```

### ClassDTO
```java
package com.schoolmgmt.class_service.dto;

import lombok.*;
import jakarta.validation.constraints.*;

@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
public class ClassDTO {
    
    private Long classId;
    
    @NotBlank(message = "Class name is required")
    @Size(max = 50)
    private String className;
    
    @NotNull(message = "Class numeric is required")
    @Min(1)
    @Max(12)
    private Integer classNumeric;
    
    @NotBlank(message = "Academic year is required")
    @Size(max = 10)
    private String academicYear;
    
    private Long classTeacherId;
}

@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
public class SubjectDTO {
    
    private Long subjectId;
    
    @NotBlank(message = "Subject name is required")
    @Size(max = 100)
    private String subjectName;
    
    @NotBlank(message = "Subject code is required")
    @Size(max = 20)
    private String subjectCode;
    
    private Long classId;
    private String subjectType;
    
    @Min(0)
    private Integer maxMarks;
    
    @Min(0)
    private Integer passMarks;
}

@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
public class TimetableDTO {
    
    private Long timetableId;
    
    @NotNull(message = "Class ID is required")
    private Long classId;
    
    private Long sectionId;
    
    @NotNull(message = "Subject ID is required")
    private Long subjectId;
    
    @NotNull(message = "Teacher ID is required")
    private Long teacherId;
    
    @NotNull(message = "Day of week is required")
    @Min(1)
    @Max(7)
    private Integer dayOfWeek;
    
    @NotNull(message = "Period number is required")
    @Min(1)
    private Integer periodNumber;
    
    @NotNull(message = "Start time is required")
    private String startTime;
    
    @NotNull(message = "End time is required")
    private String endTime;
    
    private String roomNumber;
    
    @NotBlank(message = "Academic year is required")
    private String academicYear;
}
```

### ClassService
```java
package com.schoolmgmt.class_service.service;

import com.schoolmgmt.class_service.dto.ClassDTO;
import com.schoolmgmt.class_service.dto.SubjectDTO;
import com.schoolmgmt.class_service.dto.TimetableDTO;
import com.schoolmgmt.class_service.entity.*;
import com.schoolmgmt.class_service.repository.*;
import com.schoolmgmt.config.exception.ResourceNotFoundException;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.cache.annotation.CacheEvict;
import org.springframework.cache.annotation.Cacheable;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

@Slf4j
@Service
@RequiredArgsConstructor
@Transactional
public class ClassService {
    
    private final ClassRepository classRepository;
    private final SubjectRepository subjectRepository;
    private final TimetableRepository timetableRepository;
    
    @CacheEvict(value = "classes", allEntries = true)
    public ClassDTO createClass(ClassDTO classDTO) {
        log.info("Creating new class: {}", classDTO.getClassName());
        
        Class classEntity = Class.builder()
            .className(classDTO.getClassName())
            .classNumeric(classDTO.getClassNumeric())
            .academicYear(classDTO.getAcademicYear())
            .classTeacherId(classDTO.getClassTeacherId())
            .build();
        
        classEntity = classRepository.save(classEntity);
        return mapToDTO(classEntity);
    }
    
    @Cacheable(value = "classes", key = "#id")
    public ClassDTO getClassById(Long id) {
        Class classEntity = classRepository.findById(id)
            .orElseThrow(() -> new ResourceNotFoundException("Class not found"));
        return mapToDTO(classEntity);
    }
    
    @Cacheable(value = "classes")
    public Page<ClassDTO> getAllClasses(Pageable pageable) {
        return classRepository.findAll(pageable).map(this::mapToDTO);
    }
    
    @CacheEvict(value = {"classes", "subjects"}, allEntries = true)
    public SubjectDTO createSubject(SubjectDTO subjectDTO) {
        log.info("Creating new subject: {}", subjectDTO.getSubjectName());
        
        Subject subject = Subject.builder()
            .subjectName(subjectDTO.getSubjectName())
            .subjectCode(subjectDTO.getSubjectCode())
            .classId(subjectDTO.getClassId())
            .subjectType(SubjectType.valueOf(subjectDTO.getSubjectType()))
            .maxMarks(subjectDTO.getMaxMarks())
            .passMarks(subjectDTO.getPassMarks())
            .build();
        
        subject = subjectRepository.save(subject);
        return mapSubjectToDTO(subject);
    }
    
    @Cacheable(value = "subjects", key = "#classId")
    public Page<SubjectDTO> getSubjectsByClass(Long classId, Pageable pageable) {
        return subjectRepository.findByClassId(classId, pageable)
            .map(this::mapSubjectToDTO);
    }
    
    @CacheEvict(value = {"timetables"}, allEntries = true)
    public TimetableDTO createTimetable(TimetableDTO timetableDTO) {
        log.info("Creating timetable entry");
        
        Timetable timetable = Timetable.builder()
            .classId(timetableDTO.getClassId())
            .sectionId(timetableDTO.getSectionId())
            .subjectId(timetableDTO.getSubjectId())
            .teacherId(timetableDTO.getTeacherId())
            .dayOfWeek(timetableDTO.getDayOfWeek())
            .periodNumber(timetableDTO.getPeriodNumber())
            .startTime(java.time.LocalTime.parse(timetableDTO.getStartTime()))
            .endTime(java.time.LocalTime.parse(timetableDTO.getEndTime()))
            .roomNumber(timetableDTO.getRoomNumber())
            .academicYear(timetableDTO.getAcademicYear())
            .build();
        
        timetable = timetableRepository.save(timetable);
        return mapTimetableToDTO(timetable);
    }
    
    @Cacheable(value = "timetables", key = "#classId")
    public Page<TimetableDTO> getTimetableByClass(Long classId, Pageable pageable) {
        return timetableRepository.findByClassId(classId, pageable)
            .map(this::mapTimetableToDTO);
    }
    
    private ClassDTO mapToDTO(Class classEntity) {
        return ClassDTO.builder()
            .classId(classEntity.getClassId())
            .className(classEntity.getClassName())
            .classNumeric(classEntity.getClassNumeric())
            .academicYear(classEntity.getAcademicYear())
            .classTeacherId(classEntity.getClassTeacherId())
            .build();
    }
    
    private SubjectDTO mapSubjectToDTO(Subject subject) {
        return SubjectDTO.builder()
            .subjectId(subject.getSubjectId())
            .subjectName(subject.getSubjectName())
            .subjectCode(subject.getSubjectCode())
            .classId(subject.getClassId())
            .subjectType(subject.getSubjectType().name())
            .maxMarks(subject.getMaxMarks())
            .passMarks(subject.getPassMarks())
            .build();
    }
    
    private TimetableDTO mapTimetableToDTO(Timetable timetable) {
        return TimetableDTO.builder()
            .timetableId(timetable.getTimetableId())
            .classId(timetable.getClassId())
            .sectionId(timetable.getSectionId())
            .subjectId(timetable.getSubjectId())
            .teacherId(timetable.getTeacherId())
            .dayOfWeek(timetable.getDayOfWeek())
            .periodNumber(timetable.getPeriodNumber())
            .startTime(timetable.getStartTime().toString())
            .endTime(timetable.getEndTime().toString())
            .roomNumber(timetable.getRoomNumber())
            .academicYear(timetable.getAcademicYear())
            .build();
    }
}
```

### ClassController
```java
package com.schoolmgmt.class_service.controller;

import com.schoolmgmt.class_service.dto.ClassDTO;
import com.schoolmgmt.class_service.dto.SubjectDTO;
import com.schoolmgmt.class_service.dto.TimetableDTO;
import com.schoolmgmt.class_service.service.ClassService;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.security.access.prepost.PreAuthorize;
import org.springframework.web.bind.annotation.*;

import jakarta.validation.Valid;

@Slf4j
@RestController
@RequestMapping("/classes")
@RequiredArgsConstructor
@CrossOrigin(origins = "*", maxAge = 3600)
public class ClassController {
    
    private final ClassService classService;
    
    @PostMapping
    @PreAuthorize("hasRole('ADMIN') or hasRole('PRINCIPAL')")
    public ResponseEntity<ClassDTO> createClass(@Valid @RequestBody ClassDTO classDTO) {
        log.info("Creating new class");
        ClassDTO created = classService.createClass(classDTO);
        return ResponseEntity.status(HttpStatus.CREATED).body(created);
    }
    
    @GetMapping
    @PreAuthorize("hasRole('ADMIN') or hasRole('PRINCIPAL')")
    public ResponseEntity<Page<ClassDTO>> getAllClasses(Pageable pageable) {
        log.info("Fetching all classes");
        Page<ClassDTO> classes = classService.getAllClasses(pageable);
        return ResponseEntity.ok(classes);
    }
    
    @GetMapping("/{id}")
    @PreAuthorize("hasRole('ADMIN') or hasRole('PRINCIPAL') or hasRole('TEACHER')")
    public ResponseEntity<ClassDTO> getClass(@PathVariable Long id) {
        log.info("Fetching class with ID: {}", id);
        ClassDTO classDTO = classService.getClassById(id);
        return ResponseEntity.ok(classDTO);
    }
    
    @PostMapping("/{classId}/subjects")
    @PreAuthorize("hasRole('ADMIN') or hasRole('PRINCIPAL')")
    public ResponseEntity<SubjectDTO> createSubject(
            @PathVariable Long classId,
            @Valid @RequestBody SubjectDTO subjectDTO) {
        log.info("Creating subject for class: {}", classId);
        subjectDTO.setClassId(classId);
        SubjectDTO created = classService.createSubject(subjectDTO);
        return ResponseEntity.status(HttpStatus.CREATED).body(created);
    }
    
    @GetMapping("/{classId}/subjects")
    @PreAuthorize("hasRole('ADMIN') or hasRole('PRINCIPAL') or hasRole('TEACHER')")
    public ResponseEntity<Page<SubjectDTO>> getSubjects(
            @PathVariable Long classId,
            Pageable pageable) {
        log.info("Fetching subjects for class: {}", classId);
        Page<SubjectDTO> subjects = classService.getSubjectsByClass(classId, pageable);
        return ResponseEntity.ok(subjects);
    }
    
    @PostMapping("/{classId}/timetable")
    @PreAuthorize("hasRole('ADMIN') or hasRole('PRINCIPAL')")
    public ResponseEntity<TimetableDTO> createTimetable(
            @PathVariable Long classId,
            @Valid @RequestBody TimetableDTO timetableDTO) {
        log.info("Creating timetable for class: {}", classId);
        timetableDTO.setClassId(classId);
        TimetableDTO created = classService.createTimetable(timetableDTO);
        return ResponseEntity.status(HttpStatus.CREATED).body(created);
    }
    
    @GetMapping("/{classId}/timetable")
    @PreAuthorize("hasRole('ADMIN') or hasRole('PRINCIPAL') or hasRole('TEACHER')")
    public ResponseEntity<Page<TimetableDTO>> getTimetable(
            @PathVariable Long classId,
            Pageable pageable) {
        log.info("Fetching timetable for class: {}", classId);
        Page<TimetableDTO> timetable = classService.getTimetableByClass(classId, pageable);
        return ResponseEntity.ok(timetable);
    }
}
```

---

## EXAM SERVICE

### Exam Entity
```java
package com.schoolmgmt.exam.entity;

import jakarta.persistence.*;
import lombok.*;
import java.time.LocalDate;
import java.time.LocalDateTime;

@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
@Entity
@Table(name = "exams", indexes = {
    @Index(name = "idx_class_id", columnList = "class_id"),
    @Index(name = "idx_exam_type", columnList = "exam_type")
})
public class Exam {
    
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long examId;
    
    @Column(nullable = false, length = 100)
    private String examName;
    
    @Enumerated(EnumType.STRING)
    @Column(nullable = false)
    private ExamType examType;
    
    @Column(nullable = false)
    private Long classId;
    
    @Column(nullable = false, length = 10)
    private String academicYear;
    
    @Column(nullable = false)
    private LocalDate startDate;
    
    @Column(nullable = false)
    private LocalDate endDate;
    
    @Enumerated(EnumType.STRING)
    @Column(nullable = false)
    private ExamStatus status;
    
    @Column(name = "created_at", nullable = false, updatable = false)
    private LocalDateTime createdAt;
    
    @Column(name = "updated_at")
    private LocalDateTime updatedAt;
    
    @PrePersist
    protected void onCreate() {
        this.createdAt = LocalDateTime.now();
    }
    
    @PreUpdate
    protected void onUpdate() {
        this.updatedAt = LocalDateTime.now();
    }
}

public enum ExamType {
    UNIT_TEST, MONTHLY, QUARTERLY, HALF_YEARLY, ANNUAL, ENTRANCE
}

public enum ExamStatus {
    SCHEDULED, ONGOING, COMPLETED, CANCELLED
}
```

### ExamResult Entity
```java
package com.schoolmgmt.exam.entity;

import jakarta.persistence.*;
import lombok.*;
import java.math.BigDecimal;
import java.time.LocalDateTime;

@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
@Entity
@Table(name = "exam_results", indexes = {
    @Index(name = "idx_exam_id_student", columnList = "exam_id,student_id", unique = true)
})
public class ExamResult {
    
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long resultId;
    
    @Column(nullable = false)
    private Long examId;
    
    @Column(nullable = false)
    private Long studentId;
    
    @Column(nullable = false)
    private Long subjectId;
    
    @Column(nullable = false, precision = 5, scale = 2)
    private BigDecimal marksObtained;
    
    @Column(nullable = false)
    private Integer maxMarks;
    
    @Column(length = 2)
    private String grade;
    
    @Column(columnDefinition = "TEXT")
    private String remarks;
    
    private Long enteredByTeacherId;
    
    @Column(name = "created_at", nullable = false, updatable = false)
    private LocalDateTime createdAt;
    
    @Column(name = "updated_at")
    private LocalDateTime updatedAt;
    
    @PrePersist
    protected void onCreate() {
        this.createdAt = LocalDateTime.now();
    }
    
    @PreUpdate
    protected void onUpdate() {
        this.updatedAt = LocalDateTime.now();
    }
}
```

### ExamDTO
```java
package com.schoolmgmt.exam.dto;

import lombok.*;
import jakarta.validation.constraints.*;
import java.time.LocalDate;
import java.math.BigDecimal;

@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
public class ExamDTO {
    
    private Long examId;
    
    @NotBlank(message = "Exam name is required")
    @Size(max = 100)
    private String examName;
    
    @NotNull(message = "Exam type is required")
    private String examType;
    
    @NotNull(message = "Class ID is required")
    private Long classId;
    
    @NotBlank(message = "Academic year is required")
    private String academicYear;
    
    @NotNull(message = "Start date is required")
    @FutureOrPresent
    private LocalDate startDate;
    
    @NotNull(message = "End date is required")
    private LocalDate endDate;
    
    private String status;
}

@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
public class ExamResultDTO {
    
    private Long resultId;
    
    @NotNull(message = "Exam ID is required")
    private Long examId;
    
    @NotNull(message = "Student ID is required")
    private Long studentId;
    
    @NotNull(message = "Subject ID is required")
    private Long subjectId;
    
    @NotNull(message = "Marks obtained is required")
    @DecimalMin("0.0")
    private BigDecimal marksObtained;
    
    @NotNull(message = "Max marks is required")
    @Min(1)
    private Integer maxMarks;
    
    @Size(max = 2)
    private String grade;
    
    private String remarks;
    private Long enteredByTeacherId;
}
```

### ExamService
```java
package com.schoolmgmt.exam.service;

import com.schoolmgmt.config.exception.ResourceNotFoundException;
import com.schoolmgmt.exam.dto.ExamDTO;
import com.schoolmgmt.exam.dto.ExamResultDTO;
import com.schoolmgmt.exam.entity.*;
import com.schoolmgmt.exam.repository.ExamRepository;
import com.schoolmgmt.exam.repository.ExamResultRepository;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.cache.annotation.CacheEvict;
import org.springframework.cache.annotation.Cacheable;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

@Slf4j
@Service
@RequiredArgsConstructor
@Transactional
public class ExamService {
    
    private final ExamRepository examRepository;
    private final ExamResultRepository examResultRepository;
    
    @CacheEvict(value = "exams", allEntries = true)
    public ExamDTO createExam(ExamDTO examDTO) {
        log.info("Creating new exam: {}", examDTO.getExamName());
        
        Exam exam = Exam.builder()
            .examName(examDTO.getExamName())
            .examType(ExamType.valueOf(examDTO.getExamType()))
            .classId(examDTO.getClassId())
            .academicYear(examDTO.getAcademicYear())
            .startDate(examDTO.getStartDate())
            .endDate(examDTO.getEndDate())
            .status(ExamStatus.SCHEDULED)
            .build();
        
        exam = examRepository.save(exam);
        return mapToDTO(exam);
    }
    
    @Cacheable(value = "exams", key = "#id")
    public ExamDTO getExamById(Long id) {
        Exam exam = examRepository.findById(id)
            .orElseThrow(() -> new ResourceNotFoundException("Exam not found"));
        return mapToDTO(exam);
    }
    
    @CacheEvict(value = "exams", allEntries = true)
    public ExamResultDTO enterMarks(ExamResultDTO resultDTO) {
        log.info("Entering marks for exam: {}", resultDTO.getExamId());
        
        ExamResult result = ExamResult.builder()
            .examId(resultDTO.getExamId())
            .studentId(resultDTO.getStudentId())
            .subjectId(resultDTO.getSubjectId())
            .marksObtained(resultDTO.getMarksObtained())
            .maxMarks(resultDTO.getMaxMarks())
            .grade(calculateGrade(resultDTO.getMarksObtained(), resultDTO.getMaxMarks()))
            .remarks(resultDTO.getRemarks())
            .enteredByTeacherId(resultDTO.getEnteredByTeacherId())
            .build();
        
        result = examResultRepository.save(result);
        return mapResultToDTO(result);
    }
    
    @Cacheable(value = "exam_results", key = "#examId")
    public Page<ExamResultDTO> getExamResults(Long examId, Pageable pageable) {
        return examResultRepository.findByExamId(examId, pageable)
            .map(this::mapResultToDTO);
    }
    
    private String calculateGrade(java.math.BigDecimal marks, Integer maxMarks) {
        double percentage = (marks.doubleValue() / maxMarks) * 100;
        
        if (percentage >= 90) return "A+";
        if (percentage >= 80) return "A";
        if (percentage >= 70) return "B";
        if (percentage >= 60) return "C";
        if (percentage >= 50) return "D";
        return "F";
    }
    
    private ExamDTO mapToDTO(Exam exam) {
        return ExamDTO.builder()
            .examId(exam.getExamId())
            .examName(exam.getExamName())
            .examType(exam.getExamType().name())
            .classId(exam.getClassId())
            .academicYear(exam.getAcademicYear())
            .startDate(exam.getStartDate())
            .endDate(exam.getEndDate())
            .status(exam.getStatus().name())
            .build();
    }
    
    private ExamResultDTO mapResultToDTO(ExamResult result) {
        return ExamResultDTO.builder()
            .resultId(result.getResultId())
            .examId(result.getExamId())
            .studentId(result.getStudentId())
            .subjectId(result.getSubjectId())
            .marksObtained(result.getMarksObtained())
            .maxMarks(result.getMaxMarks())
            .grade(result.getGrade())
            .remarks(result.getRemarks())
            .enteredByTeacherId(result.getEnteredByTeacherId())
            .build();
    }
}
```

### ExamController
```java
package com.schoolmgmt.exam.controller;

import com.schoolmgmt.exam.dto.ExamDTO;
import com.schoolmgmt.exam.dto.ExamResultDTO;
import com.schoolmgmt.exam.service.ExamService;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.security.access.prepost.PreAuthorize;
import org.springframework.web.bind.annotation.*;

import jakarta.validation.Valid;

@Slf4j
@RestController
@RequestMapping("/exams")
@RequiredArgsConstructor
@CrossOrigin(origins = "*", maxAge = 3600)
public class ExamController {
    
    private final ExamService examService;
    
    @PostMapping
    @PreAuthorize("hasRole('ADMIN') or hasRole('PRINCIPAL')")
    public ResponseEntity<ExamDTO> createExam(@Valid @RequestBody ExamDTO examDTO) {
        log.info("Creating new exam");
        ExamDTO created = examService.createExam(examDTO);
        return ResponseEntity.status(HttpStatus.CREATED).body(created);
    }
    
    @GetMapping("/{id}")
    @PreAuthorize("hasRole('ADMIN') or hasRole('PRINCIPAL') or hasRole('TEACHER')")
    public ResponseEntity<ExamDTO> getExam(@PathVariable Long id) {
        log.info("Fetching exam with ID: {}", id);
        ExamDTO exam = examService.getExamById(id);
        return ResponseEntity.ok(exam);
    }
    
    @PostMapping("/marks")
    @PreAuthorize("hasRole('TEACHER')")
    public ResponseEntity<ExamResultDTO> enterMarks(@Valid @RequestBody ExamResultDTO resultDTO) {
        log.info("Entering exam marks");
        ExamResultDTO result = examService.enterMarks(resultDTO);
        return ResponseEntity.status(HttpStatus.CREATED).body(result);
    }
    
    @GetMapping("/{examId}/results")
    @PreAuthorize("hasRole('ADMIN') or hasRole('PRINCIPAL') or hasRole('TEACHER')")
    public ResponseEntity<Page<ExamResultDTO>> getResults(
            @PathVariable Long examId,
            Pageable pageable) {
        log.info("Fetching results for exam: {}", examId);
        Page<ExamResultDTO> results = examService.getExamResults(examId, pageable);
        return ResponseEntity.ok(results);
    }
}
```

---

## LIBRARY SERVICE

### Book Entity
```java
package com.schoolmgmt.library.entity;

import jakarta.persistence.*;
import lombok.*;
import java.math.BigDecimal;
import java.time.LocalDate;
import java.time.LocalDateTime;

@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
@Entity
@Table(name = "books", indexes = {
    @Index(name = "idx_isbn", columnList = "isbn", unique = true),
    @Index(name = "idx_title", columnList = "title")
})
public class Book {
    
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long bookId;
    
    @Column(unique = true, length = 17)
    private String isbn;
    
    @Column(nullable = false, length = 255)
    private String title;
    
    @Column(nullable = false, length = 200)
    private String author;
    
    @Column(length = 200)
    private String publisher;
    
    private Integer publicationYear;
    
    @Column(length = 100)
    private String category;
    
    @Column(nullable = false)
    private Integer totalCopies;
    
    @Column(nullable = false)
    private Integer availableCopies;
    
    @Column(precision = 8, scale = 2)
    private BigDecimal price;
    
    @Column(length = 50)
    private String language;
    
    @Column(length = 50)
    private String shelfLocation;
    
    @Column(name = "added_date")
    private LocalDate addedDate;
    
    @Enumerated(EnumType.STRING)
    @Column(nullable = false)
    private BookStatus status;
    
    @Column(name = "created_at", nullable = false, updatable = false)
    private LocalDateTime createdAt;
    
    @Column(name = "updated_at")
    private LocalDateTime updatedAt;
    
    @PrePersist
    protected void onCreate() {
        this.createdAt = LocalDateTime.now();
        this.status = BookStatus.AVAILABLE;
    }
    
    @PreUpdate
    protected void onUpdate() {
        this.updatedAt = LocalDateTime.now();
    }
}

public enum BookStatus {
    AVAILABLE, OUT_OF_STOCK, DAMAGED, LOST
}
```

### LibraryIssue Entity
```java
package com.schoolmgmt.library.entity;

import jakarta.persistence.*;
import lombok.*;
import java.math.BigDecimal;
import java.time.LocalDate;
import java.time.LocalDateTime;

@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
@Entity
@Table(name = "library_issues", indexes = {
    @Index(name = "idx_student_id", columnList = "student_id"),
    @Index(name = "idx_book_id", columnList = "book_id")
})
public class LibraryIssue {
    
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long issueId;
    
    @Column(nullable = false)
    private Long bookId;
    
    private Long studentId;
    
    private Long teacherId;
    
    @Column(nullable = false)
    private LocalDate issuedDate;
    
    @Column(nullable = false)
    private LocalDate dueDate;
    
    private LocalDate returnDate;
    
    @Enumerated(EnumType.STRING)
    @Column(nullable = false)
    private IssueStatus status;
    
    private Long issuedByLibrarianId;
    
    private Long returnedToLibrarianId;
    
    @Column(columnDefinition = "TEXT")
    private String remarks;
    
    @Column(name = "created_at", nullable = false, updatable = false)
    private LocalDateTime createdAt;
    
    @Column(name = "updated_at")
    private LocalDateTime updatedAt;
    
    @PrePersist
    protected void onCreate() {
        this.createdAt = LocalDateTime.now();
    }
    
    @PreUpdate
    protected void onUpdate() {
        this.updatedAt = LocalDateTime.now();
    }
}

public enum IssueStatus {
    ISSUED, RETURNED, OVERDUE, LOST
}
```

### LibraryFine Entity
```java
package com.schoolmgmt.library.entity;

import jakarta.persistence.*;
import lombok.*;
import java.math.BigDecimal;
import java.time.LocalDate;
import java.time.LocalDateTime;

@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
@Entity
@Table(name = "library_fines", indexes = {
    @Index(name = "idx_issue_id", columnList = "issue_id"),
    @Index(name = "idx_payment_status", columnList = "payment_status")
})
public class LibraryFine {
    
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long fineId;
    
    @Column(nullable = false)
    private Long issueId;
    
    @Column(nullable = false, precision = 8, scale = 2)
    private BigDecimal fineAmount;
    
    @Column(length = 100)
    private String fineReason;
    
    private Integer daysOverdue;
    
    @Enumerated(EnumType.STRING)
    @Column(nullable = false)
    private FinePaymentStatus paymentStatus;
    
    private LocalDate paymentDate;
    
    @Column(length = 20)
    private String paymentMode;
    
    @Column(name = "created_at", nullable = false, updatable = false)
    private LocalDateTime createdAt;
    
    @Column(name = "updated_at")
    private LocalDateTime updatedAt;
    
    @PrePersist
    protected void onCreate() {
        this.createdAt = LocalDateTime.now();
    }
    
    @PreUpdate
    protected void onUpdate() {
        this.updatedAt = LocalDateTime.now();
    }
}

public enum FinePaymentStatus {
    PENDING, PAID, WAIVED
}
```

### LibraryDTO
```java
package com.schoolmgmt.library.dto;

import lombok.*;
import jakarta.validation.constraints.*;
import java.math.BigDecimal;
import java.time.LocalDate;

@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
public class BookDTO {
    
    private Long bookId;
    
    @Size(max = 17)
    private String isbn;
    
    @NotBlank(message = "Title is required")
    @Size(max = 255)
    private String title;
    
    @NotBlank(message = "Author is required")
    @Size(max = 200)
    private String author;
    
    @Size(max = 200)
    private String publisher;
    
    private Integer publicationYear;
    
    @Size(max = 100)
    private String category;
    
    @NotNull(message = "Total copies is required")
    @Min(1)
    private Integer totalCopies;
    
    @Min(0)
    private Integer availableCopies;
    
    @DecimalMin("0.0")
    private BigDecimal price;
    
    private String language;
    private String shelfLocation;
    private String status;
}

@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
public class LibraryIssueDTO {
    
    private Long issueId;
    
    @NotNull(message = "Book ID is required")
    private Long bookId;
    
    private Long studentId;
    private Long teacherId;
    
    @NotNull(message = "Issue date is required")
    @PastOrPresent
    private LocalDate issuedDate;
    
    @NotNull(message = "Due date is required")
    @FutureOrPresent
    private LocalDate dueDate;
    
    private LocalDate returnDate;
    private String status;
    private String remarks;
}

@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
public class LibraryFineDTO {
    
    private Long fineId;
    
    @NotNull(message = "Issue ID is required")
    private Long issueId;
    
    @NotNull(message = "Fine amount is required")
    @DecimalMin("0.01")
    private BigDecimal fineAmount;
    
    private String fineReason;
    private Integer daysOverdue;
    private String paymentStatus;
}
```

### LibraryService
```java
package com.schoolmgmt.library.service;

import com.schoolmgmt.config.exception.ResourceNotFoundException;
import com.schoolmgmt.library.dto.BookDTO;
import com.schoolmgmt.library.dto.LibraryIssueDTO;
import com.schoolmgmt.library.dto.LibraryFineDTO;
import com.schoolmgmt.library.entity.*;
import com.schoolmgmt.library.repository.*;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.cache.annotation.CacheEvict;
import org.springframework.cache.annotation.Cacheable;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.math.BigDecimal;
import java.time.LocalDate;
import java.time.temporal.ChronoUnit;

@Slf4j
@Service
@RequiredArgsConstructor
@Transactional
public class LibraryService {
    
    private final BookRepository bookRepository;
    private final LibraryIssueRepository issueRepository;
    private final LibraryFineRepository fineRepository;
    
    @CacheEvict(value = "books", allEntries = true)
    public BookDTO addBook(BookDTO bookDTO) {
        log.info("Adding new book: {}", bookDTO.getTitle());
        
        Book book = Book.builder()
            .isbn(bookDTO.getIsbn())
            .title(bookDTO.getTitle())
            .author(bookDTO.getAuthor())
            .publisher(bookDTO.getPublisher())
            .publicationYear(bookDTO.getPublicationYear())
            .category(bookDTO.getCategory())
            .totalCopies(bookDTO.getTotalCopies())
            .availableCopies(bookDTO.getTotalCopies())
            .price(bookDTO.getPrice())
            .language(bookDTO.getLanguage())
            .shelfLocation(bookDTO.getShelfLocation())
            .addedDate(LocalDate.now())
            .status(BookStatus.AVAILABLE)
            .build();
        
        book = bookRepository.save(book);
        return mapToDTO(book);
    }
    
    @Cacheable(value = "books", key = "#id")
    public BookDTO getBook(Long id) {
        Book book = bookRepository.findById(id)
            .orElseThrow(() -> new ResourceNotFoundException("Book not found"));
        return mapToDTO(book);
    }
    
    @Cacheable(value = "books_search", key = "#query")
    public Page<BookDTO> searchBooks(String query, Pageable pageable) {
        return bookRepository.searchByTitleOrAuthor(query, pageable)
            .map(this::mapToDTO);
    }
    
    @CacheEvict(value = "library_issues", allEntries = true)
    public LibraryIssueDTO issueBook(LibraryIssueDTO issueDTO) {
        log.info("Issuing book: {} to student/teacher", issueDTO.getBookId());
        
        Book book = bookRepository.findById(issueDTO.getBookId())
            .orElseThrow(() -> new ResourceNotFoundException("Book not found"));
        
        if (book.getAvailableCopies() <= 0) {
            throw new IllegalArgumentException("Book not available");
        }
        
        LibraryIssue issue = LibraryIssue.builder()
            .bookId(issueDTO.getBookId())
            .studentId(issueDTO.getStudentId())
            .teacherId(issueDTO.getTeacherId())
            .issuedDate(issueDTO.getIssuedDate())
            .dueDate(issueDTO.getDueDate())
            .status(IssueStatus.ISSUED)
            .remarks(issueDTO.getRemarks())
            .build();
        
        issue = issueRepository.save(issue);
        
        book.setAvailableCopies(book.getAvailableCopies() - 1);
        bookRepository.save(book);
        
        return mapIssueToDTO(issue);
    }
    
    @CacheEvict(value = {"library_issues", "books"}, allEntries = true)
    public LibraryIssueDTO returnBook(Long issueId) {
        log.info("Returning book with issue ID: {}", issueId);
        
        LibraryIssue issue = issueRepository.findById(issueId)
            .orElseThrow(() -> new ResourceNotFoundException("Issue record not found"));
        
        issue.setReturnDate(LocalDate.now());
        issue.setStatus(IssueStatus.RETURNED);
        
        // Check for fine if overdue
        if (LocalDate.now().isAfter(issue.getDueDate())) {
            long daysOverdue = ChronoUnit.DAYS.between(issue.getDueDate(), LocalDate.now());
            BigDecimal fineAmount = BigDecimal.valueOf(daysOverdue * 10); // 10 per day
            
            LibraryFine fine = LibraryFine.builder()
                .issueId(issueId)
                .fineAmount(fineAmount)
                .fineReason("Book overdue")
                .daysOverdue((int) daysOverdue)
                .paymentStatus(FinePaymentStatus.PENDING)
                .build();
            
            fineRepository.save(fine);
        }
        
        // Update book availability
        Book book = bookRepository.findById(issue.getBookId())
            .orElseThrow(() -> new ResourceNotFoundException("Book not found"));
        book.setAvailableCopies(book.getAvailableCopies() + 1);
        bookRepository.save(book);
        
        issue = issueRepository.save(issue);
        return mapIssueToDTO(issue);
    }
    
    @Cacheable(value = "library_fines", key = "#studentId")
    public Page<LibraryFineDTO> getStudentFines(Long studentId, Pageable pageable) {
        return fineRepository.findByStudentId(studentId, pageable)
            .map(this::mapFineToDTO);
    }
    
    private BookDTO mapToDTO(Book book) {
        return BookDTO.builder()
            .bookId(book.getBookId())
            .isbn(book.getIsbn())
            .title(book.getTitle())
            .author(book.getAuthor())
            .publisher(book.getPublisher())
            .publicationYear(book.getPublicationYear())
            .category(book.getCategory())
            .totalCopies(book.getTotalCopies())
            .availableCopies(book.getAvailableCopies())
            .price(book.getPrice())
            .language(book.getLanguage())
            .shelfLocation(book.getShelfLocation())
            .status(book.getStatus().name())
            .build();
    }
    
    private LibraryIssueDTO mapIssueToDTO(LibraryIssue issue) {
        return LibraryIssueDTO.builder()
            .issueId(issue.getIssueId())
            .bookId(issue.getBookId())
            .studentId(issue.getStudentId())
            .teacherId(issue.getTeacherId())
            .issuedDate(issue.getIssuedDate())
            .dueDate(issue.getDueDate())
            .returnDate(issue.getReturnDate())
            .status(issue.getStatus().name())
            .remarks(issue.getRemarks())
            .build();
    }
    
    private LibraryFineDTO mapFineToDTO(LibraryFine fine) {
        return LibraryFineDTO.builder()
            .fineId(fine.getFineId())
            .issueId(fine.getIssueId())
            .fineAmount(fine.getFineAmount())
            .fineReason(fine.getFineReason())
            .daysOverdue(fine.getDaysOverdue())
            .paymentStatus(fine.getPaymentStatus().name())
            .build();
    }
}
```

### LibraryController
```java
package com.schoolmgmt.library.controller;

import com.schoolmgmt.library.dto.BookDTO;
import com.schoolmgmt.library.dto.LibraryIssueDTO;
import com.schoolmgmt.library.dto.LibraryFineDTO;
import com.schoolmgmt.library.service.LibraryService;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.security.access.prepost.PreAuthorize;
import org.springframework.web.bind.annotation.*;

import jakarta.validation.Valid;

@Slf4j
@RestController
@RequestMapping("/library")
@RequiredArgsConstructor
@CrossOrigin(origins = "*", maxAge = 3600)
public class LibraryController {
    
    private final LibraryService libraryService;
    
    @PostMapping("/books")
    @PreAuthorize("hasRole('LIBRARIAN') or hasRole('ADMIN')")
    public ResponseEntity<BookDTO> addBook(@Valid @RequestBody BookDTO bookDTO) {
        log.info("Adding new book");
        BookDTO added = libraryService.addBook(bookDTO);
        return ResponseEntity.status(HttpStatus.CREATED).body(added);
    }
    
    @GetMapping("/books/{id}")
    @PreAuthorize("hasRole('STUDENT') or hasRole('TEACHER') or hasRole('LIBRARIAN')")
    public ResponseEntity<BookDTO> getBook(@PathVariable Long id) {
        log.info("Fetching book with ID: {}", id);
        BookDTO book = libraryService.getBook(id);
        return ResponseEntity.ok(book);
    }
    
    @GetMapping("/books/search")
    @PreAuthorize("hasRole('STUDENT') or hasRole('TEACHER') or hasRole('LIBRARIAN')")
    public ResponseEntity<Page<BookDTO>> searchBooks(
            @RequestParam String query,
            Pageable pageable) {
        log.info("Searching books with query: {}", query);
        Page<BookDTO> books = libraryService.searchBooks(query, pageable);
        return ResponseEntity.ok(books);
    }
    
    @PostMapping("/issue")
    @PreAuthorize("hasRole('LIBRARIAN')")
    public ResponseEntity<LibraryIssueDTO> issueBook(@Valid @RequestBody LibraryIssueDTO issueDTO) {
        log.info("Issuing book");
        LibraryIssueDTO issue = libraryService.issueBook(issueDTO);
        return ResponseEntity.status(HttpStatus.CREATED).body(issue);
    }
    
    @PutMapping("/return/{issueId}")
    @PreAuthorize("hasRole('LIBRARIAN')")
    public ResponseEntity<LibraryIssueDTO> returnBook(@PathVariable Long issueId) {
        log.info("Returning book");
        LibraryIssueDTO issue = libraryService.returnBook(issueId);
        return ResponseEntity.ok(issue);
    }
    
    @GetMapping("/fines/student/{studentId}")
    @PreAuthorize("hasRole('LIBRARIAN') or hasRole('PARENT')")
    public ResponseEntity<Page<LibraryFineDTO>> getStudentFines(
            @PathVariable Long studentId,
            Pageable pageable) {
        log.info("Fetching fines for student: {}", studentId);
        Page<LibraryFineDTO> fines = libraryService.getStudentFines(studentId, pageable);
        return ResponseEntity.ok(fines);
    }
}
```

---

## SUPPORT TICKET SERVICE

### SupportTicket Entity
```java
package com.schoolmgmt.support.entity;

import jakarta.persistence.*;
import lombok.*;
import java.time.LocalDateTime;

@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
@Entity
@Table(name = "support_tickets", indexes = {
    @Index(name = "idx_ticket_number", columnList = "ticket_number", unique = true),
    @Index(name = "idx_reported_by", columnList = "reported_by_user_id"),
    @Index(name = "idx_status", columnList = "status")
})
public class SupportTicket {
    
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long ticketId;
    
    @Column(nullable = false, unique = true, length = 50)
    private String ticketNumber;
    
    @Column(nullable = false)
    private Long reportedByUserId;
    
    @Enumerated(EnumType.STRING)
    @Column(nullable = false)
    private TicketCategory category;
    
    @Enumerated(EnumType.STRING)
    @Column(nullable = false)
    private TicketPriority priority;
    
    @Column(nullable = false, length = 200)
    private String subject;
    
    @Column(nullable = false, columnDefinition = "TEXT")
    private String description;
    
    @Enumerated(EnumType.STRING)
    @Column(nullable = false)
    private TicketStatus status;
    
    private Long assignedToAdminId;
    
    @Column(columnDefinition = "TEXT")
    private String resolution;
    
    private LocalDateTime resolvedDate;
    
    @Column(name = "created_at", nullable = false, updatable = false)
    private LocalDateTime createdAt;
    
    @Column(name = "updated_at")
    private LocalDateTime updatedAt;
    
    @PrePersist
    protected void onCreate() {
        this.createdAt = LocalDateTime.now();
    }
    
    @PreUpdate
    protected void onUpdate() {
        this.updatedAt = LocalDateTime.now();
    }
}

public enum TicketCategory {
    TECHNICAL, ACADEMIC, FINANCIAL, GENERAL, COMPLAINT
}

public enum TicketPriority {
    LOW, MEDIUM, HIGH, URGENT
}

public enum TicketStatus {
    OPEN, IN_PROGRESS, RESOLVED, CLOSED, REOPENED
}
```

### SupportTicketDTO
```java
package com.schoolmgmt.support.dto;

import lombok.*;
import jakarta.validation.constraints.*;

@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
public class SupportTicketDTO {
    
    private Long ticketId;
    private String ticketNumber;
    
    @NotNull(message = "Reported by user ID is required")
    private Long reportedByUserId;
    
    @NotNull(message = "Category is required")
    private String category;
    
    private String priority;
    
    @NotBlank(message = "Subject is required")
    @Size(max = 200)
    private String subject;
    
    @NotBlank(message = "Description is required")
    private String description;
    
    private String status;
    private Long assignedToAdminId;
    private String resolution;
}

@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
public class TicketStatusUpdateDTO {
    
    @NotNull(message = "Status is required")
    private String status;
    
    private String resolution;
}
```

### SupportTicketService
```java
package com.schoolmgmt.support.service;

import com.schoolmgmt.config.exception.ResourceNotFoundException;
import com.schoolmgmt.support.dto.SupportTicketDTO;
import com.schoolmgmt.support.dto.TicketStatusUpdateDTO;
import com.schoolmgmt.support.entity.*;
import com.schoolmgmt.support.repository.SupportTicketRepository;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.cache.annotation.CacheEvict;
import org.springframework.cache.annotation.Cacheable;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.time.LocalDateTime;
import java.util.UUID;

@Slf4j
@Service
@RequiredArgsConstructor
@Transactional
public class SupportTicketService {
    
    private final SupportTicketRepository ticketRepository;
    
    @CacheEvict(value = "support_tickets", allEntries = true)
    public SupportTicketDTO createTicket(SupportTicketDTO ticketDTO) {
        log.info("Creating new support ticket");
        
        SupportTicket ticket = SupportTicket.builder()
            .ticketNumber("TKT-" + UUID.randomUUID().toString().substring(0, 8).toUpperCase())
            .reportedByUserId(ticketDTO.getReportedByUserId())
            .category(TicketCategory.valueOf(ticketDTO.getCategory()))
            .priority(TicketPriority.valueOf(ticketDTO.getPriority() != null ? ticketDTO.getPriority() : "MEDIUM"))
            .subject(ticketDTO.getSubject())
            .description(ticketDTO.getDescription())
            .status(TicketStatus.OPEN)
            .build();
        
        ticket = ticketRepository.save(ticket);
        return mapToDTO(ticket);
    }
    
    @Cacheable(value = "support_tickets", key = "#userId")
    public Page<SupportTicketDTO> getTicketsByUser(Long userId, Pageable pageable) {
        return ticketRepository.findByReportedByUserId(userId, pageable)
            .map(this::mapToDTO);
    }
    
    @Cacheable(value = "support_tickets_all")
    public Page<SupportTicketDTO> getAllTickets(Pageable pageable) {
        return ticketRepository.findAll(pageable)
            .map(this::mapToDTO);
    }
    
    @CacheEvict(value = "support_tickets", allEntries = true)
    public SupportTicketDTO updateTicketStatus(Long ticketId, TicketStatusUpdateDTO updateDTO) {
        log.info("Updating ticket status for ticket: {}", ticketId);
        
        SupportTicket ticket = ticketRepository.findById(ticketId)
            .orElseThrow(() -> new ResourceNotFoundException("Ticket not found"));
        
        ticket.setStatus(TicketStatus.valueOf(updateDTO.getStatus()));
        ticket.setResolution(updateDTO.getResolution());
        
        if (TicketStatus.valueOf(updateDTO.getStatus()) == TicketStatus.RESOLVED) {
            ticket.setResolvedDate(LocalDateTime.now());
        }
        
        ticket = ticketRepository.save(ticket);
        return mapToDTO(ticket);
    }
    
    @CacheEvict(value = "support_tickets", allEntries = true)
    public SupportTicketDTO assignTicket(Long ticketId, Long adminId) {
        SupportTicket ticket = ticketRepository.findById(ticketId)
            .orElseThrow(() -> new ResourceNotFoundException("Ticket not found"));
        
        ticket.setAssignedToAdminId(adminId);
        ticket.setStatus(TicketStatus.IN_PROGRESS);
        
        ticket = ticketRepository.save(ticket);
        return mapToDTO(ticket);
    }
    
    private SupportTicketDTO mapToDTO(SupportTicket ticket) {
        return SupportTicketDTO.builder()
            .ticketId(ticket.getTicketId())
            .ticketNumber(ticket.getTicketNumber())
            .reportedByUserId(ticket.getReportedByUserId())
            .category(ticket.getCategory().name())
            .priority(ticket.getPriority().name())
            .subject(ticket.getSubject())
            .description(ticket.getDescription())
            .status(ticket.getStatus().name())
            .assignedToAdminId(ticket.getAssignedToAdminId())
            .resolution(ticket.getResolution())
            .build();
    }
}
```

### SupportTicketController
```java
package com.schoolmgmt.support.controller;

import com.schoolmgmt.support.dto.SupportTicketDTO;
import com.schoolmgmt.support.dto.TicketStatusUpdateDTO;
import com.schoolmgmt.support.service.SupportTicketService;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.security.access.prepost.PreAuthorize;
import org.springframework.web.bind.annotation.*;

import jakarta.validation.Valid;

@Slf4j
@RestController
@RequestMapping("/support")
@RequiredArgsConstructor
@CrossOrigin(origins = "*", maxAge = 3600)
public class SupportTicketController {
    
    private final SupportTicketService ticketService;
    
    @PostMapping("/tickets")
    @PreAuthorize("hasAnyRole('STUDENT','TEACHER','PARENT','ADMIN')")
    public ResponseEntity<SupportTicketDTO> createTicket(@Valid @RequestBody SupportTicketDTO ticketDTO) {
        log.info("Creating support ticket");
        SupportTicketDTO created = ticketService.createTicket(ticketDTO);
        return ResponseEntity.status(HttpStatus.CREATED).body(created);
    }
    
    @GetMapping("/tickets")
    @PreAuthorize("hasRole('ADMIN')")
    public ResponseEntity<Page<SupportTicketDTO>> getAllTickets(Pageable pageable) {
        log.info("Fetching all support tickets");
        Page<SupportTicketDTO> tickets = ticketService.getAllTickets(pageable);
        return ResponseEntity.ok(tickets);
    }
    
    @GetMapping("/tickets/user/{userId}")
    @PreAuthorize("hasRole('ADMIN') or #userId == authentication.principal.id")
    public ResponseEntity<Page<SupportTicketDTO>> getTicketsByUser(
            @PathVariable Long userId,
            Pageable pageable) {
        log.info("Fetching tickets for user: {}", userId);
        Page<SupportTicketDTO> tickets = ticketService.getTicketsByUser(userId, pageable);
        return ResponseEntity.ok(tickets);
    }
    
    @PatchMapping("/tickets/{ticketId}/status")
    @PreAuthorize("hasRole('ADMIN')")
    public ResponseEntity<SupportTicketDTO> updateTicketStatus(
            @PathVariable Long ticketId,
            @Valid @RequestBody TicketStatusUpdateDTO updateDTO) {
        log.info("Updating ticket status");
        SupportTicketDTO updated = ticketService.updateTicketStatus(ticketId, updateDTO);
        return ResponseEntity.ok(updated);
    }
    
    @PatchMapping("/tickets/{ticketId}/assign")
    @PreAuthorize("hasRole('ADMIN')")
    public ResponseEntity<SupportTicketDTO> assignTicket(
            @PathVariable Long ticketId,
            @RequestParam Long adminId) {
        log.info("Assigning ticket to admin: {}", adminId);
        SupportTicketDTO assigned = ticketService.assignTicket(ticketId, adminId);
        return ResponseEntity.ok(assigned);
    }
}
```

---

## NOTIFICATION SERVICE

### Notification Entity
```java
package com.schoolmgmt.notification.entity;

import jakarta.persistence.*;
import lombok.*;
import java.time.LocalDateTime;

@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
@Entity
@Table(name = "notifications", indexes = {
    @Index(name = "idx_user_id", columnList = "user_id"),
    @Index(name = "idx_created_at", columnList = "created_at")
})
public class Notification {
    
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long notificationId;
    
    private Long userId;
    
    @Column(nullable = false, length = 200)
    private String title;
    
    @Column(nullable = false, columnDefinition = "TEXT")
    private String message;
    
    @Enumerated(EnumType.STRING)
    private NotificationType notificationType;
    
    @Enumerated(EnumType.STRING)
    private NotificationChannel channel;
    
    @Column(nullable = false)
    private Boolean readStatus;
    
    private LocalDateTime readAt;
    
    @Column(length = 500)
    private String linkUrl;
    
    @Column(name = "created_at", nullable = false, updatable = false)
    private LocalDateTime createdAt;
    
    @PrePersist
    protected void onCreate() {
        this.createdAt = LocalDateTime.now();
        this.readStatus = false;
    }
}

public enum NotificationType {
    INFO, WARNING, SUCCESS, ERROR, ANNOUNCEMENT
}

public enum NotificationChannel {
    IN_APP, EMAIL, SMS, PUSH
}
```

### NotificationDTO
```java
package com.schoolmgmt.notification.dto;

import lombok.*;
import jakarta.validation.constraints.*;

@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
public class NotificationDTO {
    
    private Long notificationId;
    
    private Long userId;
    
    @NotBlank(message = "Title is required")
    @Size(max = 200)
    private String title;
    
    @NotBlank(message = "Message is required")
    private String message;
    
    private String notificationType;
    private String channel;
    private Boolean readStatus;
    private String linkUrl;
}

@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
public class BroadcastNotificationRequest {
    
    @NotBlank(message = "Title is required")
    private String title;
    
    @NotBlank(message = "Message is required")
    private String message;
    
    private String targetRole;
    private String notificationType;
    private String channel;
}
```

### NotificationService
```java
package com.schoolmgmt.notification.service;

import com.schoolmgmt.notification.dto.NotificationDTO;
import com.schoolmgmt.notification.dto.BroadcastNotificationRequest;
import com.schoolmgmt.notification.entity.*;
import com.schoolmgmt.notification.repository.NotificationRepository;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.cache.annotation.CacheEvict;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.time.LocalDateTime;

@Slf4j
@Service
@RequiredArgsConstructor
@Transactional
public class NotificationService {
    
    private final NotificationRepository notificationRepository;
    
    @CacheEvict(value = "notifications", allEntries = true)
    public NotificationDTO sendNotification(NotificationDTO notificationDTO) {
        log.info("Sending notification to user: {}", notificationDTO.getUserId());
        
        Notification notification = Notification.builder()
            .userId(notificationDTO.getUserId())
            .title(notificationDTO.getTitle())
            .message(notificationDTO.getMessage())
            .notificationType(NotificationType.valueOf(notificationDTO.getNotificationType()))
            .channel(NotificationChannel.valueOf(notificationDTO.getChannel()))
            .linkUrl(notificationDTO.getLinkUrl())
            .readStatus(false)
            .build();
        
        notification = notificationRepository.save(notification);
        return mapToDTO(notification);
    }
    
    public Page<NotificationDTO> getUserNotifications(Long userId, Pageable pageable) {
        return notificationRepository.findByUserId(userId, pageable)
            .map(this::mapToDTO);
    }
    
    public long getUnreadNotificationsCount(Long userId) {
        return notificationRepository.countByUserIdAndReadStatusFalse(userId);
    }
    
    @CacheEvict(value = "notifications", allEntries = true)
    public NotificationDTO markAsRead(Long notificationId) {
        Notification notification = notificationRepository.findById(notificationId)
            .orElseThrow(() -> new RuntimeException("Notification not found"));
        
        notification.setReadStatus(true);
        notification.setReadAt(LocalDateTime.now());
        
        notification = notificationRepository.save(notification);
        return mapToDTO(notification);
    }
    
    @CacheEvict(value = "notifications", allEntries = true)
    public void broadcastNotification(BroadcastNotificationRequest request) {
        log.info("Broadcasting notification to role: {}", request.getTargetRole());
        
        // Implementation for broadcasting to specific roles
        // This would typically query users by role and send notifications to all
    }
    
    private NotificationDTO mapToDTO(Notification notification) {
        return NotificationDTO.builder()
            .notificationId(notification.getNotificationId())
            .userId(notification.getUserId())
            .title(notification.getTitle())
            .message(notification.getMessage())
            .notificationType(notification.getNotificationType().name())
            .channel(notification.getChannel().name())
            .readStatus(notification.getReadStatus())
            .linkUrl(notification.getLinkUrl())
            .build();
    }
}
```

### NotificationController
```java
package com.schoolmgmt.notification.controller;

import com.schoolmgmt.notification.dto.NotificationDTO;
import com.schoolmgmt.notification.dto.BroadcastNotificationRequest;
import com.schoolmgmt.notification.service.NotificationService;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.security.access.prepost.PreAuthorize;
import org.springframework.web.bind.annotation.*;

import jakarta.validation.Valid;

@Slf4j
@RestController
@RequestMapping("/notifications")
@RequiredArgsConstructor
@CrossOrigin(origins = "*", maxAge = 3600)
public class NotificationController {
    
    private final NotificationService notificationService;
    
    @PostMapping("/send")
    @PreAuthorize("hasRole('ADMIN')")
    public ResponseEntity<NotificationDTO> sendNotification(@Valid @RequestBody NotificationDTO notificationDTO) {
        log.info("Sending notification");
        NotificationDTO sent = notificationService.sendNotification(notificationDTO);
        return ResponseEntity.status(HttpStatus.CREATED).body(sent);
    }
    
    @GetMapping("/user/{userId}")
    @PreAuthorize("hasRole('ADMIN') or #userId == authentication.principal.id")
    public ResponseEntity<Page<NotificationDTO>> getUserNotifications(
            @PathVariable Long userId,
            Pageable pageable) {
        log.info("Fetching notifications for user: {}", userId);
        Page<NotificationDTO> notifications = notificationService.getUserNotifications(userId, pageable);
        return ResponseEntity.ok(notifications);
    }
    
    @GetMapping("/user/{userId}/unread")
    @PreAuthorize("hasRole('ADMIN') or #userId == authentication.principal.id")
    public ResponseEntity<?> getUnreadCount(@PathVariable Long userId) {
        log.info("Fetching unread notification count for user: {}", userId);
        long count = notificationService.getUnreadNotificationsCount(userId);
        return ResponseEntity.ok(java.util.Map.of("userId", userId, "unreadCount", count));
    }
    
    @PutMapping("/{id}/read")
    @PreAuthorize("authenticated")
    public ResponseEntity<NotificationDTO> markAsRead(@PathVariable Long id) {
        log.info("Marking notification as read: {}", id);
        NotificationDTO marked = notificationService.markAsRead(id);
        return ResponseEntity.ok(marked);
    }
    
    @PostMapping("/broadcast")
    @PreAuthorize("hasRole('ADMIN') or hasRole('PRINCIPAL')")
    public ResponseEntity<Void> broadcastNotification(
            @Valid @RequestBody BroadcastNotificationRequest request) {
        log.info("Broadcasting notification");
        notificationService.broadcastNotification(request);
        return ResponseEntity.status(HttpStatus.ACCEPTED).build();
    }
}
```

---

## REPOSITORIES (Remaining Services)

```java
// Fee Repositories
public interface FeePaymentRepository extends JpaRepository<FeePayment, Long> {
    Page<FeePayment> findByStudentId(Long studentId, Pageable pageable);
    Page<FeePayment> findDefaulters(Pageable pageable);
    Optional<BigDecimal> findOutstandingAmount(Long studentId);
    Page<FeePayment> findByPaymentDateBetween(LocalDate start, LocalDate end, Pageable pageable);
}

public interface FeeStructureRepository extends JpaRepository<FeeStructure, Long> {
    List<FeeStructure> findByClassIdAndAcademicYear(Long classId, String year);
}

// Class Repositories
public interface ClassRepository extends JpaRepository<Class, Long> {}
public interface SubjectRepository extends JpaRepository<Subject, Long> {
    Page<Subject> findByClassId(Long classId, Pageable pageable);
}
public interface TimetableRepository extends JpaRepository<Timetable, Long> {
    Page<Timetable> findByClassId(Long classId, Pageable pageable);
}

// Exam Repositories
public interface ExamRepository extends JpaRepository<Exam, Long> {}
public interface ExamResultRepository extends JpaRepository<ExamResult, Long> {
    Page<ExamResult> findByExamId(Long examId, Pageable pageable);
}

// Library Repositories
public interface BookRepository extends JpaRepository<Book, Long> {
    Page<Book> searchByTitleOrAuthor(String query, Pageable pageable);
}
public interface LibraryIssueRepository extends JpaRepository<LibraryIssue, Long> {}
public interface LibraryFineRepository extends JpaRepository<LibraryFine, Long> {
    Page<LibraryFine> findByStudentId(Long studentId, Pageable pageable);
}

// Support Repositories
public interface SupportTicketRepository extends JpaRepository<SupportTicket, Long> {
    Page<SupportTicket> findByReportedByUserId(Long userId, Pageable pageable);
}

// Notification Repositories
public interface NotificationRepository extends JpaRepository<Notification, Long> {
    Page<Notification> findByUserId(Long userId, Pageable pageable);
    long countByUserIdAndReadStatusFalse(Long userId);
}
```

This comprehensive implementation provides production-ready code for all remaining services with Spring Boot 3.5.7 and Java 25 standards.
